# 版本控制策略

## 1. 版本控制概述

本文档详细描述了 `charm-experimental-packages-cn` 项目的版本控制策略，包括分支管理、代码合并流程、版本号命名规则等。合理的版本控制策略有助于提高开发效率，确保代码质量，便于项目管理和发布。

## 2. 版本控制系统

### 2.1 Git 简介

`charm-experimental-packages-cn` 项目使用 Git 作为版本控制系统。Git 是一个分布式版本控制系统，具有以下特点：

- **分布式**：每个开发者都有完整的代码仓库副本
- **高效**：支持快速的分支创建和切换
- **灵活**：支持多种工作流模式
- **安全**：使用加密哈希函数保护数据完整性

### 2.2 Git 基本概念

#### 2.2.1 仓库 (Repository)

- **本地仓库**：存储在开发者本地的代码仓库
- **远程仓库**：存储在服务器上的代码仓库，如 GitHub、GitLab 等

#### 2.2.2 分支 (Branch)

- **主分支**：稳定的代码分支，用于发布版本
- **开发分支**：集成新功能的代码分支
- **特性分支**：开发特定功能的代码分支
- **修复分支**：修复 bug 的代码分支

#### 2.2.3 提交 (Commit)

- **提交消息**：描述代码变更的消息
- **提交哈希**：唯一标识提交的哈希值
- **提交历史**：代码变更的历史记录

#### 2.2.4 合并 (Merge)

- **快进合并**：直接移动分支指针的合并
- **三方合并**：创建新的合并提交的合并
- **变基合并**：重写提交历史的合并

#### 2.2.5 标签 (Tag)

- **轻量标签**：简单的指针，指向特定提交
- **附注标签**：包含更多信息的标签，如版本号、发布说明等

## 3. 分支管理策略

### 3.1 分支模型

`charm-experimental-packages-cn` 项目采用 Git Flow 分支模型，结合 GitHub Flow 的一些特点，具体分支结构如下：

| 分支名称 | 类型 | 用途 | 来源 | 合并目标 |
|---------|------|------|------|----------|
| `main` | 主分支 | 稳定的代码分支，用于发布版本 | 初始分支 | - |
| `develop` | 开发分支 | 集成新功能的代码分支 | `main` | `main` (发布时) |
| `feature/*` | 特性分支 | 开发特定功能的代码分支 | `develop` | `develop` (功能完成后) |
| `bugfix/*` | 修复分支 | 修复 `develop` 分支中的 bug | `develop` | `develop` (修复完成后) |
| `hotfix/*` | 热修复分支 | 修复 `main` 分支中的 bug | `main` | `main` 和 `develop` (修复完成后) |
| `release/*` | 发布分支 | 准备发布版本的代码分支 | `develop` | `main` 和 `develop` (发布完成后) |

### 3.2 分支命名规范

#### 3.2.1 主分支和开发分支

- **`main`**：主分支，保持稳定，用于发布版本
- **`develop`**：开发分支，集成新功能

#### 3.2.2 特性分支

- **格式**：`feature/[功能名称]`
- **示例**：`feature/terminal-input`、`feature/color-support`
- **命名规则**：
  - 使用小写字母
  - 单词之间使用连字符 `-` 分隔
  - 功能名称应简洁明了，描述要开发的功能

#### 3.2.3 修复分支

- **格式**：`bugfix/[bug 描述]`
- **示例**：`bugfix/input-parse-error`、`bugfix/color-display`
- **命名规则**：
  - 使用小写字母
  - 单词之间使用连字符 `-` 分隔
  - bug 描述应简洁明了，描述要修复的问题

#### 3.2.4 热修复分支

- **格式**：`hotfix/[bug 描述]`
- **示例**：`hotfix/crash-on-startup`、`hotfix/security-issue`
- **命名规则**：
  - 使用小写字母
  - 单词之间使用连字符 `-` 分隔
  - bug 描述应简洁明了，描述要紧急修复的问题

#### 3.2.5 发布分支

- **格式**：`release/[版本号]`
- **示例**：`release/1.0.0`、`release/1.1.0`
- **命名规则**：
  - 使用小写字母
  - 版本号遵循语义化版本规范

### 3.3 分支生命周期

#### 3.3.1 特性分支生命周期

1. **创建**：从 `develop` 分支创建特性分支
2. **开发**：在特性分支上进行开发
3. **代码审查**：创建拉取请求，进行代码审查
4. **合并**：代码审查通过后，合并到 `develop` 分支
5. **删除**：合并完成后，删除特性分支

#### 3.3.2 修复分支生命周期

1. **创建**：从 `develop` 分支创建修复分支
2. **修复**：在修复分支上进行 bug 修复
3. **代码审查**：创建拉取请求，进行代码审查
4. **合并**：代码审查通过后，合并到 `develop` 分支
5. **删除**：合并完成后，删除修复分支

#### 3.3.3 热修复分支生命周期

1. **创建**：从 `main` 分支创建热修复分支
2. **修复**：在热修复分支上进行紧急 bug 修复
3. **代码审查**：创建拉取请求，进行代码审查
4. **合并**：代码审查通过后，合并到 `main` 和 `develop` 分支
5. **标签**：在 `main` 分支上创建版本标签
6. **删除**：合并完成后，删除热修复分支

#### 3.3.4 发布分支生命周期

1. **创建**：从 `develop` 分支创建发布分支
2. **准备**：在发布分支上进行发布准备，如版本号更新、文档更新等
3. **测试**：在发布分支上进行测试
4. **修复**：在发布分支上修复测试中发现的问题
5. **合并**：测试通过后，合并到 `main` 和 `develop` 分支
6. **标签**：在 `main` 分支上创建版本标签
7. **删除**：合并完成后，删除发布分支

## 4. 代码合并流程

### 4.1 拉取请求 (Pull Request) 流程

1. **创建分支**：从适当的基础分支创建新的分支
2. **进行开发**：在新分支上进行代码开发或 bug 修复
3. **提交代码**：提交代码变更，编写清晰的提交消息
4. **推送到远程**：将分支推送到远程仓库
5. **创建拉取请求**：在 GitHub 或 GitLab 上创建拉取请求，描述代码变更的目的和内容
6. **代码审查**：代码审查者审查代码，提供反馈
7. **修改代码**：根据代码审查反馈，修改代码
8. **通过测试**：确保代码通过所有测试
9. **合并代码**：代码审查通过后，合并代码到目标分支
10. **删除分支**：合并完成后，删除源分支

### 4.2 代码审查规范

#### 4.2.1 审查准备

- **自审查**：在创建拉取请求前，开发者应自行审查代码
- **测试**：确保代码通过所有测试
- **文档**：确保代码有适当的文档和注释
- **提交消息**：确保提交消息清晰、准确

#### 4.2.2 审查内容

- **代码质量**：代码是否符合项目的编码规范
- **功能正确性**：代码是否正确实现了预期功能
- **边界情况**：是否处理了边界情况和异常情况
- **性能**：代码是否有性能问题
- **安全性**：代码是否有安全隐患
- **可维护性**：代码是否易于维护和扩展

#### 4.2.3 审查反馈

- **具体**：反馈应具体，指出问题所在的位置和原因
- **建设性**：反馈应建设性，提供改进建议
- **及时**：反馈应及时，避免延迟项目进度
- **尊重**：反馈应尊重，避免个人攻击

#### 4.2.4 审查流程

1. **初始审查**：代码审查者进行初始审查，提供反馈
2. **修改**：开发者根据反馈修改代码
3. **重新审查**：代码审查者重新审查修改后的代码
4. **批准**：代码审查通过后，批准拉取请求
5. **合并**：合并代码到目标分支

### 4.3 合并策略

#### 4.3.1 快进合并 (Fast-forward Merge)

**适用场景**：
- 目标分支没有新的提交
- 源分支是目标分支的直接延伸

**优点**：
- 简单，直接移动分支指针
- 保持提交历史线性

**缺点**：
- 无法看出哪些提交是作为一个功能或修复一起提交的

#### 4.3.2 三方合并 (Three-way Merge)

**适用场景**：
- 目标分支有新的提交
- 需要保留合并历史

**优点**：
- 保留完整的合并历史
- 清晰地显示功能或修复的合并

**缺点**：
- 提交历史可能变得复杂
- 可能产生不必要的合并提交

#### 4.3.3 变基合并 (Rebase Merge)

**适用场景**：
- 功能分支，需要保持提交历史干净
- 避免复杂的合并历史

**优点**：
- 保持提交历史线性
- 避免不必要的合并提交

**缺点**：
- 重写提交历史，可能导致冲突
- 不适合公共分支，如 `main` 和 `develop`

### 4.4 合并冲突处理

#### 4.4.1 冲突原因

- **文件冲突**：两个分支修改了同一个文件的相同部分
- **目录冲突**：一个分支重命名了目录，另一个分支在该目录中添加了文件
- **删除冲突**：一个分支删除了文件，另一个分支修改了该文件

#### 4.4.2 冲突解决步骤

1. **识别冲突**：使用 `git status` 命令识别冲突的文件
2. **查看冲突**：打开冲突的文件，查看冲突的部分
3. **解决冲突**：编辑文件，解决冲突
4. **标记为已解决**：使用 `git add` 命令标记冲突已解决
5. **完成合并**：使用 `git commit` 命令完成合并

#### 4.4.3 冲突解决策略

- **保留一方的修改**：完全使用一方的修改，丢弃另一方的修改
- **合并双方的修改**：手动合并双方的修改，保留有用的部分
- **重新实现**：放弃双方的修改，重新实现功能

## 5. 版本号命名规则

### 5.1 语义化版本规范

`charm-experimental-packages-cn` 项目使用 [语义化版本 2.0.0](https://semver.org/lang/zh-CN/) 规范，版本号格式为：

```
MAJOR.MINOR.PATCH
```

其中：

- **MAJOR**：当进行不兼容的 API 变更时增加
- **MINOR**：当添加向后兼容的新功能时增加
- **PATCH**：当进行向后兼容的 bug 修复时增加

### 5.2 预发布版本

对于尚未稳定的版本，可以使用预发布版本标识符，格式为：

```
MAJOR.MINOR.PATCH-预发布标识符
```

预发布标识符可以是：

- **alpha**：内部测试版本
- **beta**：公开测试版本
- **rc**：候选发布版本

示例：
- `1.0.0-alpha.1`
- `1.0.0-beta.2`
- `1.0.0-rc.3`

### 5.3 版本标签规范

版本标签应使用附注标签，包含版本号和发布说明，格式为：

```bash
git tag -a vMAJOR.MINOR.PATCH -m "版本说明"
```

示例：
```bash
git tag -a v1.0.0 -m "初始发布版本"
```

### 5.4 版本发布流程

1. **版本规划**：确定要发布的版本号
2. **创建发布分支**：从 `develop` 分支创建 `release/版本号` 分支
3. **更新版本号**：在发布分支上更新版本号
4. **更新文档**：更新发布说明、README.md 等文档
5. **运行测试**：确保代码通过所有测试
6. **合并到 main**：将发布分支合并到 `main` 分支
7. **创建版本标签**：在 `main` 分支上创建版本标签
8. **合并到 develop**：将发布分支合并到 `develop` 分支
9. **删除发布分支**：删除发布分支
10. **发布版本**：在 GitHub 或 GitLab 上创建发布，上传二进制文件等

## 6. 提交规范

### 6.1 提交消息格式

`charm-experimental-packages-cn` 项目采用 [Conventional Commits](https://www.conventionalcommits.org/zh-hans/v1.0.0/) 规范，提交消息格式为：

```
<类型>[可选的作用域]: <描述>

[可选的正文]

[可选的脚注]
```

#### 6.1.1 类型

| 类型 | 描述 |
|------|------|
| `feat` | 新功能 |
| `fix` | 修复 bug |
| `docs` | 文档更新 |
| `style` | 代码风格调整（不影响功能） |
| `refactor` | 代码重构（不增加功能或修复 bug） |
| `perf` | 性能优化 |
| `test` | 测试相关 |
| `build` | 构建系统或外部依赖调整 |
| `ci` | CI 配置调整 |
| `chore` | 其他调整（不影响源代码、测试或文档） |

#### 6.1.2 作用域

作用域是可选的，用于指定提交影响的范围，如模块、组件等。示例：

```
feat(ansi): 添加 ANSI 转义序列解析
fix(cellbuf): 修复单元格缓冲区边界检查
```

#### 6.1.3 描述

描述是必填的，用于简要描述提交的内容，应：

- 简短（不超过 50 个字符）
- 清晰（描述具体的变更）
- 使用命令式语气（如 "添加"、"修复" 而不是 "添加了"、"修复了"）

#### 6.1.4 正文

正文是可选的，用于详细描述提交的内容，应：

- 换行（每行不超过 72 个字符）
- 详细说明变更的原因和影响
- 提供足够的上下文，便于代码审查和未来维护

#### 6.1.5 脚注

脚注是可选的，用于添加额外的信息，如：

- **Breaking Changes**：不兼容的 API 变更
- **Closed Issues**：关闭的 issue

示例：

```
BREAKING CHANGE: 移除了 deprecated 的函数

Closes #123
```

### 6.2 提交最佳实践

1. **单次提交**：每个提交应专注于单一功能或修复，避免混合多个不相关的变更
2. **提交粒度**：提交粒度应适中，既不过大也不过小
3. **提交消息**：提交消息应清晰、准确，遵循提交规范
4. **代码审查**：在提交前进行自审查，确保代码质量
5. **测试**：确保提交的代码通过所有测试
6. **文档**：确保提交的代码有适当的文档和注释

## 7. 标签和发布管理

### 7.1 标签管理

#### 7.1.1 标签类型

- **版本标签**：标记发布版本，如 `v1.0.0`
- **里程碑标签**：标记重要的里程碑，如 `milestone-1`
- **状态标签**：标记代码的状态，如 `stable`、`experimental`

#### 7.1.2 标签命名规范

- **版本标签**：使用 `vMAJOR.MINOR.PATCH` 格式，如 `v1.0.0`
- **里程碑标签**：使用 `milestone-数字` 格式，如 `milestone-1`
- **状态标签**：使用小写字母，如 `stable`、`experimental`

#### 7.1.3 标签操作

```bash
# 创建轻量标签
git tag v1.0.0

# 创建附注标签
git tag -a v1.0.0 -m "初始发布版本"

# 推送标签到远程仓库
git push origin v1.0.0

# 推送所有标签到远程仓库
git push origin --tags

# 删除本地标签
git tag -d v1.0.0

# 删除远程标签
git push origin --delete v1.0.0
```

### 7.2 发布管理

#### 7.2.1 发布流程

1. **发布准备**：
   - 更新版本号
   - 更新发布说明
   - 运行测试
   - 确保代码通过所有测试

2. **创建发布分支**：
   ```bash
   git checkout -b release/1.0.0 develop
   ```

3. **更新版本号**：
   - 更新代码中的版本号
   - 提交版本号更新
   ```bash
   git commit -m "build: 更新版本号到 1.0.0"
   ```

4. **合并到 main**：
   ```bash
   git checkout main
   git merge --no-ff release/1.0.0
   ```

5. **创建版本标签**：
   ```bash
   git tag -a v1.0.0 -m "初始发布版本"
   ```

6. **合并到 develop**：
   ```bash
   git checkout develop
   git merge --no-ff release/1.0.0
   ```

7. **删除发布分支**：
   ```bash
   git branch -d release/1.0.0
   ```

8. **推送变更**：
   ```bash
   git push origin main develop v1.0.0
   ```

9. **创建 GitHub/GitLab 发布**：
   - 上传二进制文件
   - 添加发布说明
   - 标记发布类型（如稳定版、测试版）

#### 7.2.2 发布说明

发布说明应包含以下内容：

- **版本号**：发布的版本号
- **发布日期**：发布的日期
- **主要变更**：主要的功能变更和 bug 修复
- **不兼容的变更**：不兼容的 API 变更
- **升级指南**：从旧版本升级的指南
- **感谢**：感谢贡献者

示例：

```markdown
# v1.0.0 发布说明

## 发布日期
2023-12-01

## 主要变更

- 添加了 ANSI 转义序列解析功能
- 实现了终端输入处理
- 修复了颜色显示问题

## 不兼容的变更

- 移除了 deprecated 的函数 `OldFunction()`

## 升级指南

1. 将依赖更新到 v1.0.0
2. 替换 `OldFunction()` 为新的 `NewFunction()`

## 感谢

感谢所有贡献者的努力！
```

## 8. 版本控制工具和集成

### 8.1 Git 客户端工具

#### 8.1.1 命令行工具

- **Git**：官方的命令行工具，功能完整
- **GitHub CLI**：GitHub 官方的命令行工具，集成了 GitHub 的功能
- **GitLab CLI**：GitLab 官方的命令行工具，集成了 GitLab 的功能

#### 8.1.2 GUI 工具

- **GitHub Desktop**：GitHub 官方的 GUI 工具，简单易用
- **GitKraken**：功能强大的 Git GUI 工具，支持多种 Git 托管服务
- **Sourcetree**：Atlassian 开发的 Git GUI 工具，支持 Mercurial
- **VS Code Git 集成**：Visual Studio Code 内置的 Git 集成，方便快捷

### 8.2 CI/CD 集成

#### 8.2.1 GitHub Actions

GitHub Actions 是 GitHub 提供的 CI/CD 服务，可以与版本控制流程集成，实现自动化测试、构建和部署。

**配置示例**：

```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24.2'
    - name: Run tests
      run: go test -v ./...
    - name: Build
      run: go build ./...
```

#### 8.2.2 GitLab CI/CD

GitLab CI/CD 是 GitLab 提供的 CI/CD 服务，功能强大，与 GitLab 无缝集成。

**配置示例**：

```yaml
stages:
  - test
  - build

variables:
  GO_VERSION: "1.24.2"

test:
  stage: test
  image: golang:$GO_VERSION
  script:
    - go test -v ./...

build:
  stage: build
  image: golang:$GO_VERSION
  script:
    - go build ./...
```

#### 8.2.3 Jenkins

Jenkins 是一个开源的 CI/CD 工具，功能强大，可扩展性高。

**配置示例**：

- 创建 Jenkins 任务，配置 Git 仓库
- 添加构建步骤，运行测试和构建
- 配置触发条件，如代码推送时触发

### 8.3 代码托管服务

#### 8.3.1 GitHub

GitHub 是最流行的代码托管服务，提供了丰富的功能，如拉取请求、代码审查、CI/CD 等。

**特点**：
- 全球最大的代码托管平台
- 丰富的生态系统
- 支持私有和公共仓库
- 集成了 GitHub Actions

#### 8.3.2 GitLab

GitLab 是一个全功能的 DevOps 平台，提供了代码托管、CI/CD、容器注册表等功能。

**特点**：
- 全功能的 DevOps 平台
- 支持自托管
- 丰富的 CI/CD 功能
- 集成了容器注册表

#### 8.3.3 Bitbucket

Bitbucket 是 Atlassian 提供的代码托管服务，与 Jira、Confluence 等工具集成。

**特点**：
- 与 Atlassian 工具集成
- 支持 Git 和 Mercurial
- 提供免费的私有仓库
- 集成了 Bitbucket Pipelines

## 9. 最佳实践

### 9.1 版本控制最佳实践

1. **频繁提交**：频繁提交代码，避免一次提交过多变更
2. **分支管理**：合理使用分支，保持分支结构清晰
3. **提交消息**：遵循提交规范，编写清晰、准确的提交消息
4. **代码审查**：进行代码审查，确保代码质量
5. **测试**：确保代码通过所有测试
6. **文档**：保持文档与代码同步
7. **标签管理**：使用标签标记重要的版本和里程碑
8. **备份**：定期备份代码仓库

### 9.2 团队协作最佳实践

1. **沟通**：保持团队成员之间的沟通，确保大家了解项目的进展
2. **约定**：制定团队的版本控制约定，如分支命名、提交规范等
3. **培训**：为团队成员提供版本控制工具的培训
4. **工具**：选择适合团队的版本控制工具和集成
5. **流程**：建立清晰的版本控制流程，如拉取请求流程、代码审查流程等
6. **反馈**：定期收集团队成员的反馈，改进版本控制流程

### 9.3 常见问题和解决方案

#### 9.3.1 提交历史混乱

**问题**：提交历史变得混乱，难以理解

**解决方案**：
- 使用变基合并整理提交历史
- 遵循提交规范，保持提交消息清晰
- 合理使用分支，避免不必要的合并

#### 9.3.2 合并冲突频繁

**问题**：合并冲突频繁，影响开发效率

**解决方案**：
- 频繁拉取和推送代码，减少分支之间的差异
- 合理划分功能，避免多个开发者同时修改相同的文件
- 使用代码审查，及早发现和解决潜在的冲突

#### 9.3.3 版本发布延迟

**问题**：版本发布延迟，影响项目进度

**解决方案**：
- 建立清晰的发布流程，明确每个步骤的责任和时间
- 使用发布分支，专门用于准备发布版本
- 自动化测试和构建，减少手动操作的时间

#### 9.3.4 代码质量下降

**问题**：代码质量下降，bug 增多

**解决方案**：
- 加强代码审查，确保代码质量
- 增加测试覆盖率，及早发现和修复 bug
- 遵循编码规范，保持代码的一致性和可读性

## 10. 总结

`charm-experimental-packages-cn` 项目的版本控制策略涵盖了分支管理、代码合并流程、版本号命名规则、提交规范等方面，旨在提高开发效率，确保代码质量，便于项目管理和发布。

通过遵循这些策略，开发团队可以：

1. **提高开发效率**：合理的分支管理和代码合并流程可以减少冲突，提高开发效率
2. **确保代码质量**：代码审查和测试可以确保代码质量，减少 bug
3. **便于项目管理**：清晰的版本号命名规则和发布流程可以便于项目管理和发布
4. **促进团队协作**：明确的约定和流程可以促进团队成员之间的协作
5. **保障项目安全**：备份和标签管理可以保障项目的安全和可追溯性

随着项目的不断发展和团队的不断壮大，版本控制策略也应不断调整和优化，以适应项目的发展需求。开发团队应定期回顾和改进版本控制策略，确保其有效性和适用性。