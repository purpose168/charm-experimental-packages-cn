package ansi

import (
	"testing"
)

// nolint
var tcases = []struct {
	name        string
	input       string
	extra       string
	width       int
	expectRight string
	expectLeft  string
}{
	{
		"ç©ºå­—ç¬¦ä¸²",
		"",
		"",
		0,
		"",
		"",
	},
	{
		"æˆªæ–­é•¿åº¦ä¸º0",
		"foo",
		"",
		0,
		"",
		"foo",
	},
	{
		"ASCIIå­—ç¬¦é•¿åº¦ç›¸ç­‰",
		"one",
		".",
		3,
		"one",
		"",
	},
	{
		"åŒ…å«emojié•¿åº¦ç›¸ç­‰",
		"onğŸ‘‹",
		".",
		3,
		"on.",
		".ğŸ‘‹",
	},
	{
		"ç®€å•å¤šå•è¯",
		"a couple of words",
		"",
		6,
		"a coup",
		"le of words",
	},
	{
		"åŒ…å«æ§åˆ¶å­—ç¬¦å’Œemojié•¿åº¦ç›¸ç­‰",
		"one\x1b[0m",
		".",
		3,
		"one\x1b[0m",
		"\x1b[0m",
	},
	{
		"æˆªæ–­å°¾éƒ¨å¤§äºåŸå­—ç¬¦ä¸²",
		"foo",
		"...",
		5,
		"foo",
		"",
	},
	{
		"ç®€å•æˆªæ–­",
		"foobar",
		"",
		3,
		"foo",
		"bar",
	},
	{
		"ä¸æˆªæ–­",
		"foobar",
		"",
		10,
		"foobar",
		"",
	},
	{
		"ASCIIå­—ç¬¦",
		"hello",
		"",
		3,
		"hel",
		"lo",
	},
	{
		"emojiå­—ç¬¦",
		"ğŸ‘‹",
		"",
		2,
		"ğŸ‘‹",
		"",
	},
	{
		"å®½emojiå­—ç¬¦",
		"ğŸ«§",
		"",
		2,
		"ğŸ«§",
		"",
	},
	{
		"æ§åˆ¶å­—ç¬¦å’Œemoji",
		"\x1b[31mhello ğŸ‘‹abc\x1b[0m",
		"",
		8,
		"\x1b[31mhello ğŸ‘‹\x1b[0m",
		"\x1b[31mabc\x1b[0m",
	},
	{
		"OSC8è¶…é“¾æ¥",
		"\x1b]8;;https://charm.sh\x1b\\Charmbracelet ğŸ«§\x1b]8;;\x1b\\",
		"",
		5,
		"\x1b]8;;https://charm.sh\x1b\\Charm\x1b]8;;\x1b\\",
		"\x1b]8;;https://charm.sh\x1b\\bracelet ğŸ«§\x1b]8;;\x1b\\",
	},
	{
		"8ä½OSC8è¶…é“¾æ¥",
		"\x9d8;;https://charm.sh\x9cCharmbracelet ğŸ«§\x9d8;;\x9c",
		"",
		5,
		"\x9d8;;https://charm.sh\x9cCharm\x9d8;;\x9c",
		"\x9d8;;https://charm.sh\x9cbracelet ğŸ«§\x9d8;;\x9c",
	},
	{
		"å¸¦æ ·å¼çš„å°¾éƒ¨",
		"\x1B[38;5;219mHiya!",
		"â€¦",
		3,
		"\x1B[38;5;219mHiâ€¦",
		"\x1B[38;5;219mâ€¦a!",
	},
	{
		"åŒæ ·å¼å°¾éƒ¨",
		"\x1B[38;5;219mHiya!\x1B[38;5;219mHello",
		"â€¦",
		7,
		"\x1B[38;5;219mHiya!\x1B[38;5;219mHâ€¦",
		"\x1B[38;5;219m\x1B[38;5;219mâ€¦llo",
	},
	{
		"æ— æ“ä½œ",
		"\x1B[7m--",
		"",
		2,
		"\x1B[7m--",
		"\x1b[7m",
	},
	{
		"åŒå®½åº¦å­—ç¬¦",
		"\x1B[38;2;249;38;114mä½ å¥½\x1B[0m",
		"",
		3,
		"\x1B[38;2;249;38;114mä½ \x1B[0m",
		"\x1B[38;2;249;38;114må¥½\x1B[0m",
	},
	{
		"å•ä¸ªåŒå®½åº¦å­—ç¬¦",
		"ä½ ",
		"",
		1,
		"",
		"ä½ ",
	},
	{
		"å¤šä¸ªåŒå®½åº¦å­—ç¬¦",
		"ä½ å¥½",
		"",
		2,
		"ä½ ",
		"å¥½",
	},
	{
		"ä»…ç©ºæ ¼",
		"    ",
		"â€¦",
		2,
		" â€¦",
		"â€¦  ",
	},
	{
		"è¾ƒé•¿çš„å°¾éƒ¨",
		"foo",
		"...",
		2,
		"",
		"...o",
	},
	{
		"å°¾éƒ¨å®½åº¦ä¸åŸå­—ç¬¦ä¸²ç›¸åŒ",
		"foo",
		"...",
		3,
		"foo",
		"",
	},
	{
		"å¸¦æ§åˆ¶å­—ç¬¦çš„å°¾éƒ¨å®½åº¦ç›¸åŒ",
		"\x1b[31mfoo\x1b[0m",
		"...",
		3,
		"\x1b[31mfoo\x1b[0m",
		"\x1b[31m\x1b[0m",
	},
	{
		"å®½åº¦ç›¸åŒ",
		"foo",
		"",
		3,
		"foo",
		"",
	},
	{
		"å¸¦å°¾éƒ¨æˆªæ–­",
		"foobar",
		".",
		4,
		"foo.",
		".ar",
	},
	{
		"å¸¦æ ·å¼",
		"I really \x1B[38;2;249;38;114mlove\x1B[0m Go!",
		"",
		8,
		"I really\x1B[38;2;249;38;114m\x1B[0m",
		" \x1B[38;2;249;38;114mlove\x1B[0m Go!",
	},
	{
		"DCSæ§åˆ¶åºåˆ—",
		"\x1BPq#0;2;0;0;0#1;2;100;100;0#2;2;0;100;0#1~~@@vv@@~~@@~~$#2??}}GG}}??}}??-#1!14@\x1B\\foobar",
		"â€¦",
		4,
		"\x1BPq#0;2;0;0;0#1;2;100;100;0#2;2;0;100;0#1~~@@vv@@~~@@~~$#2??}}GG}}??}}??-#1!14@\x1B\\fooâ€¦",
		"\x1BPq#0;2;0;0;0#1;2;100;100;0#2;2;0;100;0#1~~@@vv@@~~@@~~$#2??}}GG}}??}}??-#1!14@\x1B\\â€¦ar",
	},
	{
		"emojiå°¾éƒ¨",
		"\x1b[36mHello there!\x1b[m",
		"ğŸ˜ƒ",
		8,
		"\x1b[36mHello ğŸ˜ƒ\x1b[m",
		"\x1b[36mğŸ˜ƒere!\x1b[m",
	},
	{
		"Unicodeå­—ç¬¦",
		"\x1b[35mClaireâ€˜s Boutique\x1b[0m",
		"",
		8,
		"\x1b[35mClaireâ€˜s\x1b[0m",
		"\x1b[35m Boutique\x1b[0m",
	},
	{
		"å®½å­—ç¬¦",
		"ã“ã‚“ã«ã¡ã¯",
		"â€¦",
		7,
		"ã“ã‚“ã«â€¦",
		"â€¦ã¡ã¯",
	},
	{
		"å¸¦æ ·å¼çš„å®½å­—ç¬¦",
		"\x1b[35mã“ã‚“ã«ã¡ã¯\x1b[m",
		"â€¦",
		7,
		"\x1b[35mã“ã‚“ã«â€¦\x1b[m",
		"\x1b[35mâ€¦ã¡ã¯\x1b[m",
	},
	{
		"å¸¦æ¢è¡Œçš„OSC8",
		"à¸ªà¸§à¸±à¸ªà¸”à¸µà¸ªà¸§à¸±à¸ªà¸”à¸µ\x1b]8;;https://example.com\x1b\\\nà¸ªà¸§à¸±à¸ªà¸”à¸µà¸ªà¸§à¸±à¸ªà¸”à¸µ\x1b]8;;\x1b\\",
		"â€¦",
		9,
		"à¸ªà¸§à¸±à¸ªà¸”à¸µà¸ªà¸§à¸±à¸ªà¸”à¸µ\x1b]8;;https://example.com\x1b\\\nâ€¦\x1b]8;;\x1b\\",
		"\x1b]8;;https://example.com\x1b\\â€¦à¸§à¸±à¸ªà¸”à¸µà¸ªà¸§à¸±à¸ªà¸”à¸µ\x1b]8;;\x1b\\",
	},
	{
		"ç®€å•æ—¥æ–‡æ–‡æœ¬å‰ç¼€/åç¼€",
		"è€è¨±ãƒ±ãƒ¨ã‚«ãƒèª¿å‡ºã‚ã‚†ç›£",
		"â€¦",
		13,
		"è€è¨±ãƒ±ãƒ¨ã‚«ãƒâ€¦",
		"â€¦èª¿å‡ºã‚ã‚†ç›£",
	},
	{
		"ç®€å•æ—¥æ–‡æ–‡æœ¬",
		"è€è¨±ãƒ±ãƒ¨ã‚«ãƒèª¿å‡ºã‚ã‚†ç›£",
		"",
		14,
		"è€è¨±ãƒ±ãƒ¨ã‚«ãƒèª¿",
		"å‡ºã‚ã‚†ç›£",
	},
	{
		"æ¢è¡Œç¬¦åœ¨èŒƒå›´å†…å¤–",
		"\n\nsomething\nin\nthe\nway\n\n",
		"-",
		10,
		"\n\nsomething\n-",
		"-n\nthe\nway\n\n",
	},
	{
		"å¸¦æ¢è¡Œçš„å¤šå®½åº¦å­—ç¬¦ - æ—¥æ–‡æ–‡æœ¬",
		`è€è¨±ãƒ±ãƒ¨ã‚«ãƒèª¿å‡ºã‚ã‚†ç›£ä»¶ã³ç†åˆ¥ã‚ˆãƒ³åœ‹çµ¦ç½ãƒ¬ãƒ›ãƒæ¨©è¼ãƒ¢ã‚¨ãƒ•ä¼šå‰²ã‚‚ãƒ•éŸ¿3ç¾ã‚¨ãƒ„æ–‡æ™‚ã—ã ã³ã»çµŒæ©Ÿãƒ ã‚¤ãƒ¡ãƒ•æ•—æ–‡ãƒ¨ã‚¯ç¾ç¾©ãªã•ãƒ‰è«‹æƒ…ã‚†ã˜ã‚‡ã¦æ†¶ä¸»ç®¡å·ã‘ã§ãµãã€‚æ’ã‚ƒã‚ã¤ã’ç¾åˆŠãƒ±ãƒŸå‡ºè¦‹ãƒ„å—è€…ã‚ªæŠœè±†ãƒãƒˆãƒ­ãƒè«–ç´¢ãƒ¢ãƒãƒ‹ã‚¤ä»»å„Ÿã‚¹ãƒ²è©±ç ´ãƒªãƒ¤ãƒ¨ç§’æ­¢å£ã‚¤ã‚»ã‚½ã‚¹æ­¢å¤®ã®ã•é£Ÿå‘¨å¥ã§ã¦ã¤ã å®˜é€ãƒˆèª­è´éŠå®¹ã²ã‚‹ã¹ã€‚éš›ããƒ‰ã‚‰ã¥å¸‚å±…ãƒãƒ ãƒ¤ç ”æ ¡35å²©6ç¹¹ã”ã‚ã‚¯å ±æ‹ã‚¤é©æ·±52çƒã‚ƒãƒ¬ã‚¹ã”ç©¶æ±ã‚¹ãƒ©è¡3é–“ãƒ©éŒ²å ãŸã‚¹ã€‚

ç¦ã«ãƒ³ã”å¿˜åº·ã–ã»ããƒ«é¨°èˆ¬ã­ã©äº‹è¶…ã‚¹ã‚“ã„ã†çœŸè¡¨ä½•ã‚«ãƒ¢è‡ªæµ©ãƒ²ã‚·ãƒŸå›³å®¢ç·šã‚‹ãµé™ç‹ã±ãƒ¼ã¾å†™æ‘æœˆæ›ç„¼è©é¢ãã‚ƒã€‚æ˜‡å¼·ã”ãƒ³ãƒˆã»ä¾¡ä¿ã‚­æ—85å²¡ãƒ¢ãƒ†æ‹å›°ã²ã‚Šã“ãªåˆŠä¸¦ã›ã”å‡ºæ¥ã¼ãã‚€ã†ç‚¹ç›®ãƒ²ã‚¦æ­¢ç’°å…¬ãƒ‹ãƒ¬äº‹å¿œã‚¿ã‚¹å¿…æ›¸ã‚¿ãƒ¡ãƒ ãƒå½“84ç„¡ä¿¡å‡ã¡ã²ã‚‡ã€‚ä¾¡ãƒ¼ãä¸­å®¢ãƒ†ã‚µå‘Šè¦§ãƒ¨ãƒˆãƒæ¥µæ•´
ãƒ©å¾—95ç¨¿ã¯ã‹ãƒ©ã›æ±Ÿåˆ©ã‚¹å®ä¸¸éœŠãƒŸè€ƒæ•´ã‚¹é™å°†ãšæ¥­å·¨è·ãƒãƒ©ãƒ›åå—…ã–ãªã€‚`,
		"",
		14,
		"è€è¨±ãƒ±ãƒ¨ã‚«ãƒèª¿",
		`å‡ºã‚ã‚†ç›£ä»¶ã³ç†åˆ¥ã‚ˆãƒ³åœ‹çµ¦ç½ãƒ¬ãƒ›ãƒæ¨©è¼ãƒ¢ã‚¨ãƒ•ä¼šå‰²ã‚‚ãƒ•éŸ¿3ç¾ã‚¨ãƒ„æ–‡æ™‚ã—ã ã³ã»çµŒæ©Ÿãƒ ã‚¤ãƒ¡ãƒ•æ•—æ–‡ãƒ¨ã‚¯ç¾ç¾©ãªã•ãƒ‰è«‹æƒ…ã‚†ã˜ã‚‡ã¦æ†¶ä¸»ç®¡å·ã‘ã§ãµãã€‚æ’ã‚ƒã‚ã¤ã’ç¾åˆŠãƒ±ãƒŸå‡ºè¦‹ãƒ„å—è€…ã‚ªæŠœè±†ãƒãƒˆãƒ­ãƒè«–ç´¢ãƒ¢ãƒãƒ‹ã‚¤ä»»å„Ÿã‚¹ãƒ²è©±ç ´ãƒªãƒ¤ãƒ¨ç§’æ­¢å£ã‚¤ã‚»ã‚½ã‚¹æ­¢å¤®ã®ã•é£Ÿå‘¨å¥ã§ã¦ã¤ã å®˜é€ãƒˆèª­è´éŠå®¹ã²ã‚‹ã¹ã€‚éš›ããƒ‰ã‚‰ã¥å¸‚å±…ãƒãƒ ãƒ¤ç ”æ ¡35å²©6ç¹¹ã”ã‚ã‚¯å ±æ‹ã‚¤é©æ·±52çƒã‚ƒãƒ¬ã‚¹ã”ç©¶æ±ã‚¹ãƒ©è¡3é–“ãƒ©éŒ²å ãŸã‚¹ã€‚

ç¦ã«ãƒ³ã”å¿˜åº·ã–ã»ããƒ«é¨°èˆ¬ã­ã©äº‹è¶…ã‚¹ã‚“ã„ã†çœŸè¡¨ä½•ã‚«ãƒ¢è‡ªæµ©ãƒ²ã‚·ãƒŸå›³å®¢ç·šã‚‹ãµé™ç‹ã±ãƒ¼ã¾å†™æ‘æœˆæ›ç„¼è©é¢ãã‚ƒã€‚æ˜‡å¼·ã”ãƒ³ãƒˆã»ä¾¡ä¿ã‚­æ—85å²¡ãƒ¢ãƒ†æ‹å›°ã²ã‚Šã“ãªåˆŠä¸¦ã›ã”å‡ºæ¥ã¼ãã‚€ã†ç‚¹ç›®ãƒ²ã‚¦æ­¢ç’°å…¬ãƒ‹ãƒ¬äº‹å¿œã‚¿ã‚¹å¿…æ›¸ã‚¿ãƒ¡ãƒ ãƒå½“84ç„¡ä¿¡å‡ã¡ã²ã‚‡ã€‚ä¾¡ãƒ¼ãä¸­å®¢ãƒ†ã‚µå‘Šè¦§ãƒ¨ãƒˆãƒæ¥µæ•´
ãƒ©å¾—95ç¨¿ã¯ã‹ãƒ©ã›æ±Ÿåˆ©ã‚¹å®ä¸¸éœŠãƒŸè€ƒæ•´ã‚¹é™å°†ãšæ¥­å·¨è·ãƒãƒ©ãƒ›åå—…ã–ãªã€‚`,
	},
}

func TestTruncate(t *testing.T) {
	for i, c := range tcases {
		t.Run(c.name, func(t *testing.T) {
			if result := Truncate(c.input, c.width, c.extra); result != c.expectRight {
				t.Errorf("æµ‹è¯•ç”¨ä¾‹ %d å¤±è´¥:\né¢„æœŸ: %q\nå®é™…: %q", i+1, c.expectRight, result)
			}
		})
	}
}

func BenchmarkTruncateString(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		b.ReportAllocs()
		b.ResetTimer()
		for pb.Next() {
			Truncate("foo", 2, "")
		}
	})
}

func TestTruncateLeft(t *testing.T) {
	for i, c := range tcases {
		t.Run(c.name, func(t *testing.T) {
			if result := TruncateLeft(c.input, c.width, c.extra); result != c.expectLeft {
				t.Errorf("æµ‹è¯•ç”¨ä¾‹ %d å¤±è´¥:\né¢„æœŸ: %q\nå®é™…: %q", i+1, c.expectLeft, result)
			}
		})
	}
}

func BenchmarkTruncateLeft(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		b.ReportAllocs()
		b.ResetTimer()
		for pb.Next() {
			TruncateLeft("foo", 2, "")
		}
	})
}

func TestCut(t *testing.T) {
	for i, c := range []struct {
		desc   string
		input  string
		left   int
		right  int
		expect string
	}{
		{
			"ç®€å•å­—ç¬¦ä¸²",
			"This is a long string", 2, 6,
			"is i",
		},
		{
			"åŒ…å«ANSIæ§åˆ¶åºåˆ—",
			"I really \x1B[38;2;249;38;114mlove\x1B[0m Go!", 4, 25,
			"ally \x1b[38;2;249;38;114mlove\x1b[0m Go!",
		},
		{
			"å·¦è¾¹ç•Œä¸º0",
			"Foo \x1B[38;2;249;38;114mbar\x1B[0mbaz", 0, 5,
			"Foo \x1B[38;2;249;38;114mb\x1B[0m",
		},
		{
			"å³è¾¹ç•Œä¸º0",
			"\x1b[7mHello\x1b[m", 3, 0,
			"",
		},
		{
			"å³è¾¹ç•Œå°äºå·¦è¾¹ç•Œ",
			"\x1b[7mHello\x1b[m", 3, 2,
			"",
		},
		{
			"æˆªå–å¤§å°ä¸º0",
			"\x1b[7mHello\x1b[m", 2, 2,
			"",
		},
		{
			"ä¿æŒANSIåºåˆ—æ‰“å¼€çŠ¶æ€",
			"\x1b[38;5;212;48;5;63mHello, Artichoke!\x1b[m", 7, 16,
			"\x1b[38;5;212;48;5;63mArtichoke\x1b[m",
		},
		{
			"å¤šè¡Œæ–‡æœ¬",
			"\n\x1b[38;2;98;98;98m\nif [ -f RE\nADME.md ]; then\x1b[m\n\x1b[38;2;98;98;98m    echo oi\x1b[m\n\x1b[38;2;98;98;98mfi\x1b[m\n", 8, 13,
			"\x1b[38;2;98;98;98mRE\nADM\x1b[m\x1b[38;2;98;98;98m\x1b[m\x1b[38;2;98;98;98m\x1b[m",
		},
	} {
		t.Run(c.desc, func(t *testing.T) {
			got := Cut(c.input, c.left, c.right)
			if got != c.expect {
				t.Errorf("%s (#%d):\né¢„æœŸ: %q\nå®é™…: %q", c.desc, i+1, c.expect, got)
			}
		})
	}
}

func TestByteToGraphemeRange(t *testing.T) {
	cases := []struct {
		name   string
		feed   [2]int
		expect [2]int
		input  string
	}{
		{
			name:   "ç®€å•å­—ç¬¦ä¸²",
			input:  "hello world from x/ansi",
			feed:   [2]int{2, 9},
			expect: [2]int{2, 9},
		},
		{
			name:   "åŒ…å«emoji",
			input:  "î˜• Downloads",
			feed:   [2]int{4, 7},
			expect: [2]int{2, 5},
		},
		{
			name:   "èµ·å§‹è¶…å‡ºè¾¹ç•Œ",
			input:  "some text",
			feed:   [2]int{-1, 5},
			expect: [2]int{0, 5},
		},
		{
			name:   "ç»“æŸè¶…å‡ºè¾¹ç•Œ",
			input:  "some text",
			feed:   [2]int{1, 50},
			expect: [2]int{1, 9},
		},
	}

	for _, tt := range cases {
		t.Run(tt.name, func(t *testing.T) {
			charStart, charStop := ByteToGraphemeRange(tt.input, tt.feed[0], tt.feed[1])
			if expect := tt.expect[0]; expect != charStart {
				t.Errorf("é¢„æœŸèµ·å§‹ä½ç½®ä¸º %d, å®é™…ä¸º %d", expect, charStart)
			}
			if expect := tt.expect[1]; expect != charStop {
				t.Errorf("é¢„æœŸç»“æŸä½ç½®ä¸º %d, å®é™…ä¸º %d", expect, charStop)
			}
		})
	}
}
